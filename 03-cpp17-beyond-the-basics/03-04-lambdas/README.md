# Section 4 - Lambdas

## What Is a Lambda?

A **lambda** is an expression that represents doing something

Imagine handling an operation or function (code) to some other operation or function, which is useful for:
  * Generic work
  * A functional programming style
  * Concurrency
  * Readabilty (very important!)
    * Eliminates tiny functions used in conjunction with function pointers

## Tiny Functions

Consider the following example of a lambda:
```cpp
// defining a lambda
auto isOdd = [](int candidate) { return candidate % 2 != 0; };

// using a lambda
bool is3Odd = isOdd(3);
bool is4Odd = isOdd(4);
```

From the example above:
  * The return type of a lambda is complicated; it is generally necessary to use the compiler's type deduction via keyword `auto` to store its value in a variable
  * A lambda has the general syntax `[...](...) {...};`
    * `(...)` takes a list of parameters (e.g., `int candidate`)
    * `{ ... }` holds the body of the lambda, which defines the action of the lambda function
    
Lambdas can be particularly useful when combind with Standard Library features, e.g.,:
```cpp
vector nums { 2, 3, 4, -1, 1 };
int odds = std::count_if(begin(nums), end(nums), isOdd); // N.B. this code is much more readable than the equivalent using function pointers
```

### **DEMO: Simple Lambdas**

cf. `/Lambdas`

## Parts of a Lambda

While trivial, the lambda `[](){}` is a valid one
  * `[]` is the **capture clause**, which can be empty
    * Any variables from the calling scope that are placed in the capture clause are accessible in the lambda
  * `()` is the parameters list (similarly to a function)
  * `{}` is the body (similarly to a function)

## Behind the Scenes

### Wait, What Is a Lambda Really?

The compiler generates an anonymous function object using the information provided in the lambda

The function object is itself a class generated by the compiler containing member variables and member functions
  * In particular, one of its member functions is an override of the operator `(` (the **function call operator**), such that:
    * the parameters list is contained in `(...)`
    * the return type is (commmonly) deduced by the compiler, or can also be user-specified
    * the body is placed in the `{ ... }` of the lambda
  * The member variables are controlled by the capture clause, all of which are `const` by default (i.e., their values cannot be changed unless you explicitly indicate the intent to do so)
    * The exact nature of these member variables depends on the capture clause (discussed next)

## Lambda Captures

An empty capture clause (i.e., `[]`) captures nothing, and indicates that the lambda will only use function parameters
  * This is done quite commonly

However, it is also a typical use case to use variables from the calling scope of the lambda to be used in the lambda's body; this is controlled by the capture clause
  * `[x, y]` captures `x` and `y` by value
    * Copies of `x` and `y` are made
    * The lambda can be used *later*, even after `x` and `y` have gone out of scope (i.e., they are "captured" by the lambda)
  * `[&x, &y]` captures `x` and `y` by reference
    * No copies of `x` and `y` are made, and changes in the lambda affect the originals
    * Dangling references may be an issue (e.g., if `x` and/or `y` go out of scope, such as in concurrency work)
  * `[x=a+1, y=std::move(b)]` uses alias (`x`) and move (`y`) captures
    * Generally, for using these more complicated captures, they will become more apparently useful "when you need it" (i.e., with time and experience)
  * `[=]` copies "everything" *by value* from the calling scope
    * This capture will automatically infer the pertinent variables based on the lambda body's use of variables from the calling scope (i.e., captures only "everything" that is actually used)
    * This avoids the tedium of manually including many variables
  * `[&]` copies "everything" (i.e., that is actually used in the lambda body) *by reference*
  * The keyword `mutable` can also be used in the lambda declaration to allow changing values that are captured by reference

### How to Capture?

If the lambda is not being stored in a variable, then there is virtually no distinction between capturing by value vs. capturing by reference
  * The "usual guidelines" apply in this case (e.g., a large, expensive object is more amenable to capturing by reference to avoid an expensive copy, whereas built-in literals can be captured by value)

If the lambda is being stored in a variable or being passed on for concurrency work (e.g., an asynchronous action), however, then capture by value to avoid losing values that go out of scope

Use "everything" notation whenever possible, as it is well designed to optimize capturing (i.e., as minimally as necessary) and avoids tedious/cumbersome captures

### **DEMO: Captures**

cf. `/Captures`

## Return Value

Lambdas may return a value
  * If there is a (single, unique) `return` statement in the lambda's body, the return type can be deduced by the compiler
  * However, if the compiler cannot deduce the return type (e.g., if there are multiple return statements with different types), then the developer specifies the return type via `->` (e.g., `[](int n) -> double { ... }`)

## Parameters

As with the return value, the parameter(s) that the lambda takes is not always under the user's control, but rather is generally imposed by the place you are using the lambda (e.g., as a **predicate** in a Standard Library algorithm)
  * Therefore, this aspect of designing a lambda is generally similar to writing any other predicate (i.e., imposed by the calling function)

N.B. A predicate is a parameter that is not a value but rather "a thing to do"

## Syntactic Sugar

You could use **function objects** (also called **functors**) wherever you can use lambdas

And in many cases (e.g., Standard Library algorithms such as `std::sort`) you can just use a function pointer

But we simply did not do these things before, and now we do thanks to lambdas!

Lambdas kep the code where it is used
  * For readability
  * For expressivity (i.e., show your intent)
  * For assurance: nobody else uses this lambda, so you can freely change it without breaking code elsewhere in the code base

## Summary

It can be argued that lambdas are "only" syntactic sugar, but in practice they have changed a lot in the modern C++ landscape

Lambdas make `for_each` and other Standard Library functions much more usable

Lambdas open the door for interesting work in concurrency, parallel, and functional programming

C++ lambdas offer more control than lambdas in other languages
  * Capturing by value/reference
  * Move captures and alias captures
  * etc.
